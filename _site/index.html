<html><head><title>sup</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Jakub Kozłowski" /><meta name="description" content="Functional healthchecks in Scala" /><meta name="og:image" content="/img/poster.png" /><meta name="image" property="og:image" content="/img/poster.png" /><meta name="og:title" content="sup" /><meta name="title" property="og:title" content="sup" /><meta name="og:site_name" content="sup" /><meta name="og:url" content="https://github.com/kubukoz/sup" /><meta name="og:type" content="website" /><meta name="og:description" content="Functional healthchecks in Scala" /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="sup" /><meta name="twitter:image" content="https://sup.kubukoz.com/img/poster.png" /><meta name="twitter:description" content="Functional healthchecks in Scala" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:creator" content="@kubukoz" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/default.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /></head><body><header id="site-header"><div class="navbar-wrapper"><div class="container"><div class="row"><div class="col-xs-6"><a href="/" class="brand"><div class="icon-wrapper"><span>sup</span></div></a></div><div class="col-xs-6"><nav class="text-right"><ul class=""><li><a href="https://github.com/kubukoz/sup"><i class="fa fa-github"></i><span class="hidden-xs">GitHub</span></a></li></ul></nav></div></div></div></div><div class="jumbotron"><div class="container"><h1 class="text-center">Functional healthchecks in Scala</h1><h2></h2><p class="text-center"><a href="https://github.com/kubukoz/sup" class="btn btn-outline-inverse">View on GitHub</a></p></div></div><div><ul class="horizontalNav">      </ul></div></header><main id="site-main"><section class="use"><div class="container"><div id="content"><h1 id="sup">sup</h1>

<p><a href="http://www.apache.org/licenses/LICENSE-2.0.txt"><img src="http://img.shields.io/:license-Apache%202-green.svg" alt="License" /></a></p>

<p>‘sup provides composable, purely functional healthchecks.</p>

<h2 id="installation">Installation</h2>

<p>For sbt:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>libraryDependencies += "com.kubukoz" %% "sup-core" % "0.1.0"
</code></pre></div></div>

<p>For ammonite:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import $ivy.`com.kubukoz::sup-core:0.1.0`
</code></pre></div></div>

<p>Imports:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">sup._</span>
</code></pre></div></div>

<h2 id="main-concepts">Main concepts</h2>

<ul>
  <li>Health</li>
  <li>HealthResult</li>
  <li>HealthCheck</li>
</ul>

<h3 id="health">Health</h3>

<p><code class="highlighter-rouge">Health</code> is a boolean-like health status. In ADT notation:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Health</span> <span class="o">=</span> <span class="kt">Sick</span> <span class="o">|</span> <span class="kt">Healthy</span>
</code></pre></div></div>

<p>It has a commutative monoid, which is equivalent to the “all” monoid for booleans.</p>

<p>That means <code class="highlighter-rouge">Health</code> values can be combined with the following semantics:</p>

<table>
  <thead>
    <tr>
      <th>|+|</th>
      <th><strong>Sick</strong></th>
      <th><strong>Healthy</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Sick</strong></td>
      <td>Sick</td>
      <td>Sick</td>
    </tr>
    <tr>
      <td><strong>Healthy</strong></td>
      <td>Sick</td>
      <td>Healthy</td>
    </tr>
  </tbody>
</table>

<h3 id="healthresult">HealthResult</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//simplified
</span><span class="k">type</span> <span class="kt">HealthResult</span><span class="o">[</span><span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="n">H</span><span class="o">[</span><span class="kt">Health</span><span class="o">]</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HealthResult</code> is a wrapper over a collection <code class="highlighter-rouge">H</code> of <code class="highlighter-rouge">Health</code>.
There are no limitations about what kind of collection that must be, but it’s recommended
that it has a <code class="highlighter-rouge">cats.Foldable</code> instance. For a single Health, <code class="highlighter-rouge">cats.Id</code> can be used.</p>

<p>Other examples of a suitable type include:</p>

<ul>
  <li><code class="highlighter-rouge">cats.Id</code>: there’s only one result.</li>
  <li><code class="highlighter-rouge">sup.Tagged[String, ?]</code>: there’s only one result, tagged with a String (e.g. the dependency’s name)</li>
  <li><code class="highlighter-rouge">cats.data.NonEmptyList</code>: there are multiple checks</li>
  <li><code class="highlighter-rouge">cats.data.OneAnd[cats.data.NonEmptyList, ?]</code>: there’s one check, and a <code class="highlighter-rouge">NonEmptyList</code> of checks</li>
  <li><code class="highlighter-rouge">cats.data.OneAnd[sup.TaggedNel[String, ?], ?]</code>: there’s one check, and a <code class="highlighter-rouge">NonEmptyList</code> of checks tagged with a <code class="highlighter-rouge">String</code>.</li>
</ul>

<p><code class="highlighter-rouge">HealthResult[H]</code> has a <code class="highlighter-rouge">Monoid</code> for any <code class="highlighter-rouge">H[_]: Applicative</code>, although most of its usages will be transparent to the user.</p>

<h3 id="healthcheck">HealthCheck</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//simplified
</span><span class="k">trait</span> <span class="nc">HealthCheck</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">check</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">HealthResult</span><span class="o">[</span><span class="kt">H</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HealthCheck[F, H]</code> is a health-checking action with effects of type <code class="highlighter-rouge">F</code> that’ll result in a collection <code class="highlighter-rouge">H</code> of <code class="highlighter-rouge">Health</code>.</p>

<p>Similarly to <code class="highlighter-rouge">HealthResult</code>, a <code class="highlighter-rouge">HealthCheck[F, H]</code> has a monoid for any <code class="highlighter-rouge">F[_]: Applicative, H[_]: Applicative</code>.
This is really cool, because thanks to this we can combine two similar healhchecks into one that’ll check both.</p>

<p>Let’s start with some cats imports (assume they’re available in the rest of the page):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span><span class="o">,</span> <span class="n">cats</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">cats</span><span class="o">.</span><span class="n">effect</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">cats</span><span class="o">.</span><span class="n">implicits</span><span class="o">.</span><span class="k">_</span>
</code></pre></div></div>

<p>and here’s how healthchecks can be combined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//will always be Sick
</span><span class="k">def</span> <span class="n">queue1</span><span class="k">:</span> <span class="kt">HealthCheck</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Id</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HealthCheck</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="nc">Health</span><span class="o">.</span><span class="nc">Sick</span><span class="o">)</span>
<span class="c1">// queue1: sup.HealthCheck[cats.effect.IO,cats.Id]
</span>
<span class="c1">//will always be Healthy
</span><span class="k">def</span> <span class="n">queue2</span><span class="k">:</span> <span class="kt">HealthCheck</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Id</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HealthCheck</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="nc">Health</span><span class="o">.</span><span class="nc">Healthy</span><span class="o">)</span>
<span class="c1">// queue2: sup.HealthCheck[cats.effect.IO,cats.Id]
</span>
<span class="c1">//will always be Sick
</span><span class="k">def</span> <span class="n">queues</span> <span class="k">=</span> <span class="n">queue1</span> <span class="o">|+|</span> <span class="n">queue2</span>
<span class="c1">// queues: sup.HealthCheck[cats.effect.IO,cats.Id]
</span></code></pre></div></div>

<h2 id="advanced-concepts">Advanced concepts</h2>

<p>In sup, a single dependency’s healthcheck has the same underlying structure as a whole service’s healthcheck
consisting of multiple dependencies’ checks.</p>

<h3 id="healthreporter">HealthReporter</h3>

<p>A healthcheck wrapping multiple healthchecks is called a <code class="highlighter-rouge">HealthReporter</code>. Here’s how it’s defined in sup:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.OneAnd</span>

<span class="k">type</span> <span class="kt">HealthReporter</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HealthCheck</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">OneAnd</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>You can construct one from a sequence of healthchecks using the <code class="highlighter-rouge">HealthReporter.fromChecks</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">kafka</span><span class="k">:</span> <span class="kt">HealthCheck</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Id</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HealthCheck</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="nc">Health</span><span class="o">.</span><span class="nc">Healthy</span><span class="o">)</span>
<span class="c1">// kafka: sup.HealthCheck[cats.effect.IO,cats.Id] = sup.HealthCheck$$anon$1@21c7c0f8
</span>
<span class="k">val</span> <span class="n">postgres</span><span class="k">:</span> <span class="kt">HealthCheck</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Id</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HealthCheck</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="nc">Health</span><span class="o">.</span><span class="nc">Healthy</span><span class="o">)</span>
<span class="c1">// postgres: sup.HealthCheck[cats.effect.IO,cats.Id] = sup.HealthCheck$$anon$1@4b64497d
</span>
<span class="k">val</span> <span class="n">reporter</span><span class="k">:</span> <span class="kt">HealthReporter</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">NonEmptyList</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HealthReporter</span><span class="o">.</span><span class="n">fromChecks</span><span class="o">(</span><span class="n">kafka</span><span class="o">,</span> <span class="n">postgres</span><span class="o">)</span>
<span class="c1">// reporter: sup.HealthReporter[cats.effect.IO,cats.data.NonEmptyList] = sup.HealthReporter$$anon$1@7ad036d2
</span></code></pre></div></div>

<h3 id="tagging">Tagging</h3>

<p>A healthcheck can be tagged with a label, e.g. a <code class="highlighter-rouge">String</code> with the dependency’s name:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">sup.mods._</span>
<span class="c1">// import sup.mods._
</span>
<span class="k">val</span> <span class="n">kafkaTagged</span> <span class="k">=</span> <span class="n">kafka</span><span class="o">.</span><span class="n">mapK</span><span class="o">(</span><span class="n">mods</span><span class="o">.</span><span class="n">tagWith</span><span class="o">(</span><span class="s">"kafka"</span><span class="o">))</span>
<span class="c1">// kafkaTagged: sup.HealthCheck[cats.effect.IO,[H]sup.data.Tagged[String,H]] = sup.transformed.MappedKHealthCheck@52b57ebf
</span>
<span class="k">val</span> <span class="n">postgresTagged</span> <span class="k">=</span> <span class="n">postgres</span><span class="o">.</span><span class="n">mapK</span><span class="o">(</span><span class="n">mods</span><span class="o">.</span><span class="n">tagWith</span><span class="o">(</span><span class="s">"postgres"</span><span class="o">))</span>
<span class="c1">// postgresTagged: sup.HealthCheck[cats.effect.IO,[H]sup.data.Tagged[String,H]] = sup.transformed.MappedKHealthCheck@66807ba
</span>
<span class="k">val</span> <span class="n">taggedReporter</span> <span class="k">=</span> <span class="nc">HealthReporter</span><span class="o">.</span><span class="n">fromChecks</span><span class="o">(</span><span class="n">kafkaTagged</span><span class="o">,</span> <span class="n">postgresTagged</span><span class="o">)</span>
<span class="c1">// taggedReporter: sup.HealthReporter[cats.effect.IO,[A]cats.data.NonEmptyList[sup.data.Tagged[String,A]]] = sup.HealthReporter$$anon$1@20920e5a
</span></code></pre></div></div>

<h2 id="modifiers">Modifiers</h2>

<p>sup provides a variety of ways to customize a healthcheck. These include <code class="highlighter-rouge">mapK</code>, <code class="highlighter-rouge">transform</code>, <code class="highlighter-rouge">mapResult</code> and <code class="highlighter-rouge">leftMapK</code>
(the method that fits a modifier best is mentioned in each modifier’s Scaladoc).
Check out the predefined modifiers in the <code class="highlighter-rouge">sup.mods</code> object or create your own.</p>

<p>Here are some example modifiers provided by sup:</p>

<h3 id="timeouttosick"><code class="highlighter-rouge">timeoutToSick</code></h3>

<p>A check modified with <code class="highlighter-rouge">timeoutToSick</code> will be marked as sick if it doesn’t complete within the given duration.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="c1">// import scala.concurrent.duration._
</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">contextShift</span><span class="k">:</span> <span class="kt">ContextShift</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">contextShift</span><span class="o">(</span><span class="n">scala</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>
<span class="c1">// contextShift: cats.effect.ContextShift[cats.effect.IO] = cats.effect.internals.IOContextShift@b78825a
</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">timer</span><span class="k">:</span> <span class="kt">Timer</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">timer</span><span class="o">(</span><span class="n">scala</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">)</span>
<span class="c1">// timer: cats.effect.Timer[cats.effect.IO] = cats.effect.internals.IOTimer@67b13e46
</span>
<span class="k">val</span> <span class="n">timedKafka</span> <span class="k">=</span> <span class="n">kafka</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">mods</span><span class="o">.</span><span class="n">timeoutToSick</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">))</span>
<span class="c1">// timedKafka: sup.HealthCheck[cats.effect.IO,cats.Id] = sup.transformed.TransformedHealthCheck@2cc40980
</span></code></pre></div></div>

<p>Other modifiers with timeouts include <code class="highlighter-rouge">timeoutToDefault</code> and <code class="highlighter-rouge">timeoutToFailure</code>.</p>

<h3 id="tagwith--untag"><code class="highlighter-rouge">tagWith</code> / <code class="highlighter-rouge">untag</code></h3>

<p>Tag a healthcheck with a value (or unwrap a tagged healthcheck):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">taggedKafka2</span> <span class="k">=</span> <span class="n">kafka</span><span class="o">.</span><span class="n">mapK</span><span class="o">(</span><span class="n">mods</span><span class="o">.</span><span class="n">tagWith</span><span class="o">(</span><span class="s">"foo"</span><span class="o">))</span>
<span class="c1">// taggedKafka2: sup.HealthCheck[cats.effect.IO,[H]sup.data.Tagged[String,H]] = sup.transformed.MappedKHealthCheck@2e91958f
</span></code></pre></div></div>
</div></div></section><section class="technologies"><div class="container"><div class="row"></div></div></section></main><footer id="site-footer"><div class="container"><div class="row"><div class="col-xs-6"><p>sup is designed and developed by <a href="https://github.com/kubukoz/sup" target="_blank">Jakub Kozłowski</a></p></div><div class="col-xs-6"><p class="text-right"><a href="https://github.com/kubukoz/sup"><span class="fa fa-github"></span>View on GitHub</a></p></div></div><div class="row"><div class="col-xs-6"><p>Website built with <a href="https://47deg.github.io/sbt-microsites/" target="_blank">Sbt-microsites</a> - © 2016 <a href="https://www.47deg.com/" target="_blank">47 Degrees</a></p></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script></body></html>